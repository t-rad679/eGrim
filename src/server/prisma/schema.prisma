generator client {
  provider = "prisma-client-js"
}

generator typegraphql {
  provider                  = "typegraphql-prisma"
  emitRedundantTypesInfo    = true
  omitInputFieldsByDefault  = ["id", "createdAt", "updatedAt", "moonPhase"]
  omitOutputFieldsByDefault = ["passwordHash"]
  output                    = "../../../out/type-graphql"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Base models
model User {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  events    Event[]
  locations Location[]
  people    Person[]      @relation("Person_createdByUser")
  roles     Role[]        @default([USER])
  spreads   TarotSpread[]
  self      Person?       @relation("Person_selfToUser")
  tags      Tag[]
  decks     TarotDeck[]
  tools     Tool[]

  passwordHash String
  username     String @unique
}

enum Role {
  ADMIN
  USER
}

model Event {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  location     Location?             @relation(fields: [locationId], references: [id])
  locationId   String?
  ritual       Ritual?
  tags         TagToObjectRelation[]
  tarotReading TarotReading?
  type         EventType

  date        DateTime
  description String
  // TODO: Consider making a model for this
  mood        String?
  // TODO: Consider adding more astrological data?
  moonPhase   Decimal // If this is null, the API we use to fetch it has failed and we should throw an error
  notes       String?
  outdoor     Boolean  @default(false)
  pictures    String[]

  // Contrary to expectation, Event is somehow experiencing symptoms similar to the bug related to
  // Relations with no non-relational data
  // See https://github.com/MichalLytek/typegraphql-prisma/issues/19
  dummy Int?
}

enum EventType {
  JOURNAL_ENTRY
  RITUAL
  SPOOKY_THING
  SYNCHRONICITY
  TAROT
}

// TODO: Consider a "public" field, deciding whether other users can access it
model Location {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  name String

  user   User   @relation(fields: [userId], references: [id])
  userId String

  Event Event[]
  tags  TagToObjectRelation[]

  address     String?
  city        String?
  country     String?
  description String?
  state       String?
  zip         String?

  @@unique([userId, name])
}

model Person {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation("Person_createdByUser", fields: [userId], references: [id])
  userId String

  selfUser   User?   @relation("Person_selfToUser", fields: [selfUserId], references: [id])
  selfUserId String? @unique // This is redundant, but makes things much easier when working with it

  tags                                TagToObjectRelation[]
  querentOrReaderPersonRelation       TarotQuerentOrReaderPersonRelation[]
  participantPersonToRitualRelation   ParticipantPersonToRitualRelation[]
  WielderPersonToToolRelationRelation WielderPersonToToolRelationRelation[]

  name        String
  description String?

  @@unique([userId, name])
}

model Tag {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  tagToObjectRelations TagToObjectRelation[]

  name String

  @@unique([userId, name])
}

model TagToObjectRelation {
  id String @id @default(uuid()) // id field exists because multi-field IDs must be required

  tag   Tag    @relation(fields: [tagId], references: [id])
  tagId String

  event           Event?         @relation(fields: [eventId], references: [id])
  eventId         String?
  location        Location?      @relation(fields: [locationId], references: [id])
  locationId      String?
  person          Person?        @relation(fields: [personId], references: [id])
  personId        String?
  ritualResults   RitualResults? @relation(fields: [ritualResultsId], references: [id])
  ritualResultsId String?
  tarotCard       TarotCard?     @relation(fields: [tarotCardId], references: [id])
  tarotCardId     String?
  tarotCardDraw   TarotCardDraw? @relation(fields: [tarotCardDrawId], references: [id])
  tarotCardDrawId String?
  tarotDeck       TarotDeck?     @relation(fields: [tarotDeckId], references: [id])
  tarotDeckId     String?
  tarotDeckCard   TarotDeckCard? @relation(fields: [tarotDeckCardId], references: [id])
  tarotDeckCardId String?
  tarotPosition   TarotPosition? @relation(fields: [tarotPositionId], references: [id])
  tarotPositionId String?
  tool            Tool?          @relation(fields: [toolId], references: [id])
  toolId          String?
  tarotSpread     TarotSpread?   @relation(fields: [tarotSpreadId], references: [id])
  tarotSpreadId   String?

  dummy Int? // https://github.com/MichalLytek/typegraphql-prisma/issues/19

  @@unique([tagId, eventId, locationId, personId, ritualResultsId, tarotCardId, tarotCardDrawId, tarotDeckId, tarotDeckCardId, tarotPositionId, toolId, tarotSpreadId], name: "TagToObjectRelationCompoundId")
}

// Ritual models
model Ritual {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  event          Event                               @relation(fields: [eventId], references: [id])
  eventId        String                              @unique
  // TODO: validate that querent and reader are in participants for tarot readings
  participants   ParticipantPersonToRitualRelation[]
  results        RitualResults?
  toolRelation   ToolToRitualRelation[]
  toolRelationId String

  // TODO: Consider making steps a model, but I'm not sure what I would put in there
  steps String[]
}

model RitualResults {
  id        String                @id @default(uuid())
  createdAt DateTime              @default(now())
  updatedAt DateTime              @updatedAt
  tags      TagToObjectRelation[]
  success   Boolean
  notes     String?
  ritual    Ritual                @relation(fields: [ritualId], references: [id])
  ritualId  String                @unique
}

enum RitualRole {
  LEADER
  PARTICIPANT
  SPECTATOR
}

model Tool {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  tags         TagToObjectRelation[]
  toolRelation ToolToRitualRelation[]

  name String
}

model ToolToRitualRelation {
  ritual   Ritual @relation(fields: [ritualId], references: [id])
  ritualId String
  tool     Tool   @relation(fields: [toolId], references: [id])
  toolId   String

  wieldersRelation WielderPersonToToolRelationRelation[]

  dummy Int? // https://github.com/MichalLytek/typegraphql-prisma/issues/19

  @@id([toolId, ritualId])
}

model WielderPersonToToolRelationRelation {
  toolToRitualRelationRitualId String
  toolToRitualRelationToolId   String
  wielderId                    String

  wielder              Person               @relation(fields: [wielderId], references: [id])
  toolToRitualRelation ToolToRitualRelation @relation(fields: [toolToRitualRelationToolId, toolToRitualRelationRitualId], references: [toolId, ritualId])

  dummy Int? // https://github.com/MichalLytek/typegraphql-prisma/issues/19

  @@id([toolToRitualRelationRitualId, toolToRitualRelationToolId, wielderId])
}

model ParticipantPersonToRitualRelation {
  personId String
  ritualId String

  person Person     @relation(fields: [personId], references: [id])
  ritual Ritual     @relation(fields: [ritualId], references: [id])
  role   RitualRole

  @@id([personId, ritualId])
}

// Tarot models
model TarotReading {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cardsDrawn                TarotCardDraw[]
  event                     Event                                @relation(fields: [eventId], references: [id])
  eventId                   String                               @unique
  // TODO: Validate that both exist in the resolver. Make field resolvers for them
  querentAndReaderRelations TarotQuerentOrReaderPersonRelation[]
  spread                    TarotSpread                          @relation(fields: [spreadId], references: [id])
  spreadId                  String

  dummy Int? // https://github.com/MichalLytek/typegraphql-prisma/issues/19
}

model TarotQuerentOrReaderPersonRelation {
  person         Person       @relation(fields: [personId], references: [id])
  personId       String
  tarotReading   TarotReading @relation(fields: [tarotReadingId], references: [id])
  tarotReadingId String

  role TarotRole

  @@id([personId, role, tarotReadingId])
}

enum TarotRole {
  QUERENT
  READER
}

model TarotSpread {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  positions    TarotPosition[]
  tags         TagToObjectRelation[]
  tarotReading TarotReading[]

  name        String
  description String
}

model TarotPosition {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  cardDrawn     TarotCardDraw[]
  tags          TagToObjectRelation[]
  tarotSpread   TarotSpread           @relation(fields: [tarotSpreadId], references: [id])
  tarotSpreadId String

  description String
  number      Int
}

model TarotCardDraw {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  position       TarotPosition         @relation(fields: [positionId], references: [id])
  positionId     String
  tags           TagToObjectRelation[]
  tarotReading   TarotReading          @relation(fields: [tarotReadingId], references: [id])
  tarotReadingId String

  notes String?
}

model TarotCard {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  suit          TarotSuit
  tags          TagToObjectRelation[]
  tarotDeckCard TarotDeckCard[]

  name   String
  notes  String
  number Int
}

enum TarotSuit {
  CUPS
  PENTACLES
  SWORDS
  WANDS
  MAJOR_ARCANA
}

model TarotDeckCard {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  card        TarotCard             @relation(fields: [cardId], references: [id])
  cardId      String
  tags        TagToObjectRelation[]
  tarotDeck   TarotDeck             @relation(fields: [tarotDeckId], references: [id])
  tarotDeckId String

  notes    String
  pictures String
}

model TarotDeck {
  id        String   @id @default(uuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id])
  userId String

  tags  TagToObjectRelation[]
  cards TarotDeckCard[]

  name  String
  notes String
}
